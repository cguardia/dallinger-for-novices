
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Networks &#8212; Dallinger for Programming Novices 0.0.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Participants" href="participant.html" />
    <link rel="prev" title="Transformations" href="transformation.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="networks">
<h1>Networks<a class="headerlink" href="#networks" title="Permalink to this headline">¶</a></h1>
<p>Networks are another type of object created by Dallinger, with their own table just like all the other types of objects.</p>
<div class="figure">
<img alt="" src="_static/class_chart.jpg" />
</div>
<div class="section" id="what-is-a-network">
<h2>What is a Network?<a class="headerlink" href="#what-is-a-network" title="Permalink to this headline">¶</a></h2>
<p>Networks are the spaces in which all of the other objects we have covered so far (Nodes, Vectors, etc) exist. Nonetheless they are also objects themselves, with each corresponding table row referring to a single Network. If this feels a bit strange, think about how your chair is an object contained within your house, which is itself an object. Or try drawing a collection of Nodes and Vectors on a piece of paper - the paper itself is the Network.</p>
<p>The main question you probably have though is how does a Network know to arrange the Nodes and Vectors in the right way? As we will see below, Networks aren’t just a blank page in which other objects are stored, rather they come with a few rules as well and these rules determine the structure that Networks take. The rules don’t describe the final structure of the Network (though this can be deduced from the rules) rather they describe how a Network grows as new Nodes are added and when this growth should stop.</p>
<p>Having a table for Networks obviously allows the creation of multiple Networks (each occupying a different row in the table). It might seem unclear why this is permitted, but the answer is that it allows the experimenter to easily run multiple parallel conditions or experimental repeats at the same time, with each Network corresponding to a different condition or repeat. Participants who take part in the experiment can take part in each Network sequentially, take part in only a subset of them or take part in just a single Network. This is all configurable on an experiment-by-experiment basis and we will see how when we come to the <code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class.</p>
<p>Below, we’ll first cover the base <code class="docutils literal notranslate"><span class="pre">Network</span></code> class and then go over a few examples so you can get a feel for things.</p>
</div>
<div class="section" id="the-network-table">
<h2>The Network Table<a class="headerlink" href="#the-network-table" title="Permalink to this headline">¶</a></h2>
<p>As ever, Networks inherit the common columns defined by <code class="docutils literal notranslate"><span class="pre">SharedMixin</span></code> (see the Node page for more info on this), but they get a few extra ones too:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#: How big the network can get, this number is used by the full()</span>
<span class="c1">#: method to decide whether the network is full</span>
<span class="n">max_size</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>

<span class="c1">#: Whether the network is currently full</span>
<span class="n">full</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1">#: The role of the network. By default dallinger initializes all</span>
<span class="c1">#: networks as either &quot;practice&quot; or &quot;experiment&quot;</span>
<span class="n">role</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">26</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">max_size</span></code> is an integer that tells you the greatest number of Nodes the Network is allowed to contain. This is used, as we will see below, to let Dallinger know when the Network has finished growing. At this point the Network will not longer accept any new Nodes and the experiment will stop.</p>
<p><code class="docutils literal notranslate"><span class="pre">full</span></code> is a boolean (true or false) that tells you whether the Network has any space left for new Nodes. It’s basically a quicker way of checking whether the number of Nodes in the Network is currently less than <code class="docutils literal notranslate"><span class="pre">max_size</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">role</span></code> is used for experimental conditions. It is very common in experiments that you will run multiple conditions. For instance, if you wanted to explore the effect of communication on participants’ performance at a task, you might have an experimental condition where communication was allowed and a control condition where it is not. Each Network would need to know whether it was a control or an experiment Network and you can set the value of <code class="docutils literal notranslate"><span class="pre">role</span></code> accordingly. Then, when the Network is following its automatic growth rules, these can check for the <code class="docutils literal notranslate"><span class="pre">role</span></code> of the Network and behave accordingly. You can set <code class="docutils literal notranslate"><span class="pre">role</span></code> to whatever you want (we’ll see this in action in some of the demo experiments), but, Dallinger automatically recognizes one specific role: “practice”. By default participants will first take part in any Networks with the <code class="docutils literal notranslate"><span class="pre">role</span></code> set to “practice”, and only then will they move on to other Networks. We’ll dig into this in more detail in the section on the Experiment class.</p>
</div>
<div class="section" id="network-objects">
<h2>Network Objects<a class="headerlink" href="#network-objects" title="Permalink to this headline">¶</a></h2>
<p>Networks are big and have a lot of functions that do a whole bunch of different things. Like many of the previous classes we have looked at the functions fall into two broad categories: functions that get things about the Network and functions that make the Network do things. We’ll go through them in the order they appear in models.py.</p>
<p>First is the <code class="docutils literal notranslate"><span class="pre">network.nodes()</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">participant_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get nodes in the network.</span>

<span class="sd">    type specifies the type of Node. Failed can be &quot;all&quot;, False</span>
<span class="sd">    (default) or True. If a participant_id is passed only</span>
<span class="sd">    nodes with that participant_id will be returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="n">Node</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid node type.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">failed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid node failed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">failed</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">participant_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">failed</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span>\
                <span class="o">.</span><span class="n">query</span>\
                <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                           <span class="n">participant_id</span><span class="o">=</span><span class="n">participant_id</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span>\
                <span class="o">.</span><span class="n">query</span>\
                <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                           <span class="n">participant_id</span><span class="o">=</span><span class="n">participant_id</span><span class="p">,</span>
                           <span class="n">failed</span><span class="o">=</span><span class="n">failed</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">failed</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span>\
                <span class="o">.</span><span class="n">query</span>\
                <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span>\
                <span class="o">.</span><span class="n">query</span>\
                <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">failed</span><span class="o">=</span><span class="n">failed</span><span class="p">,</span> <span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>This returns a list of Nodes that exist within the Network. It takes a few different parameters. The first is <code class="docutils literal notranslate"><span class="pre">type</span></code>. Recall from the section on Nodes that Dallinger includes several different types of Nodes (and moreover that users are welcome to create their own). If you pass Node type (e.g. <code class="docutils literal notranslate"><span class="pre">Agent</span></code>) as a parameter in function calls to this function, it will filter the list of returned Nodes such that only Nodes of that type will be returned. So if you only want Agents, you can call <code class="docutils literal notranslate"><span class="pre">network.nodes(type=Agent)</span></code>. If you don’t list a Class, all suitable Nodes are returned.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">failed</span></code> parameter determines whether you want failed Nodes to be returned. Remember that a Network might contain a mix of failed and not-failed Nodes because sometimes participants do strange things, or bugs crop up and a participant’s data needs to be removed as the experiment runs. Failing does exactly this, and so most of the time when you ask for a Network’s Nodes you probably don’t want to include failed Nodes. This is why <code class="docutils literal notranslate"><span class="pre">failed</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>. However, if you want to include the failed Nodes you can set it to <code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>. Moreover, if you only want the failed Nodes you can set it to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>The last parameter is <code class="docutils literal notranslate"><span class="pre">participant_id</span></code>. As we will see later Nodes can be associated with Participant objects and this is a way to filter by <code class="docutils literal notranslate"><span class="pre">participant_id</span></code>. So if you want only the nodes associcated with Participant 2 you can call <code class="docutils literal notranslate"><span class="pre">network.nodes(participant_id=2)</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;How many nodes in a network.</span>

<span class="sd">    type specifies the class of node, failed</span>
<span class="sd">    can be True/False/all.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="n">failed</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">size()</span></code> tells you the current number of Nodes in the Network. As you can see it is a simple wrapper around the <code class="docutils literal notranslate"><span class="pre">nodes()</span></code> function where rather than returning the list of Nodes, it just tells you the length. Like <code class="docutils literal notranslate"><span class="pre">nodes()</span></code> it takes <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">failed</span></code> as parameters (though not <code class="docutils literal notranslate"><span class="pre">participant_id</span></code> for some reason).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get infos in the network.</span>

<span class="sd">    type specifies the type of info (defaults to Info). failed { False,</span>
<span class="sd">    True, &quot;all&quot; } specifies the failed state of the infos. To get infos</span>
<span class="sd">    from a specific node, see the infos() method in class</span>
<span class="sd">    :class:`~dallinger.models.Node`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="n">Info</span>
    <span class="k">if</span> <span class="n">failed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid failed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">failed</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">failed</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">query</span>\
            <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>\
            <span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span>
            <span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="n">failed</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">infos()</span></code> returns a list of Infos in the Network. Just like <code class="docutils literal notranslate"><span class="pre">nodes()</span></code> you can filter by <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">failed</span></code>. You can’t filter by the Node that made the Infos though. If you want to do that you should use the Node’s <code class="docutils literal notranslate"><span class="pre">infos()</span></code> function instead which we covered in the section on Nodes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transmissions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get transmissions in the network.</span>

<span class="sd">    status { &quot;all&quot;, &quot;received&quot;, &quot;pending&quot; }</span>
<span class="sd">    failed { False, True, &quot;all&quot; }</span>
<span class="sd">    To get transmissions from a specific vector, see the</span>
<span class="sd">    transmissions() method in class Vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">status</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;pending&quot;</span><span class="p">,</span> <span class="s2">&quot;received&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;You cannot get transmission of status </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="o">+</span>
            <span class="s2">&quot;Status can only be pending, received or all&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">failed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid failed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">failed</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">failed</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Transmission</span><span class="o">.</span><span class="n">query</span>\
                <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Transmission</span><span class="o">.</span><span class="n">query</span>\
                <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="n">failed</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">failed</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Transmission</span><span class="o">.</span><span class="n">query</span>\
                <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Transmission</span><span class="o">.</span><span class="n">query</span>\
                <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span>
                    <span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="n">failed</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">transmissions()</span></code> function returns a list of Transmissions in the Network. As the experiment runs this list might get extremely long and so most of the time you probably want to ask a specific Node for its Transmissions (i.e. <code class="docutils literal notranslate"><span class="pre">node.transmissions()</span></code>) rather than the Network itself, but it’s here in case you need it. As with most functions that get Transmissions, you can filter by the status of the Transmissions (“pending” for Transmissions that have been sent but not yet received, “received” for Transmissions that have been both sent and received, and “all” for both of these sets together). And as with most functions that get any type of object you can filter by failed (<code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transformations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get transformations in the network.</span>

<span class="sd">    type specifies the type of transformation (default = Transformation).</span>
<span class="sd">    failed = { False, True, &quot;all&quot; }</span>

<span class="sd">    To get transformations from a specific node,</span>
<span class="sd">    see Node.transformations().</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="n">Transformation</span>

    <span class="k">if</span> <span class="n">failed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid failed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">failed</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">failed</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">query</span>\
            <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>\
            <span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">query</span>\
            <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="n">failed</span><span class="p">)</span>\
            <span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Transformations()</span></code> returns a list of transformations that occured in this Network. You can filter by the <code class="docutils literal notranslate"><span class="pre">type</span></code> of transformation as well as by <code class="docutils literal notranslate"><span class="pre">failed</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">latest_transmission_recipient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the node that most recently received a transmission.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">attrgetter</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">Transmission</span><span class="o">.</span><span class="n">query</span>\
        <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="s2">&quot;received&quot;</span><span class="p">,</span> <span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>\
        <span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">ts</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;receive_time&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">destination</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">latest_transmission_recipient</span></code> returns the Node that most recently received a Transmission. Note that this excludes nodes that have been sent Transmissions but have not yet received them. This function might seem a little niche, but its very handy in experiments where a sequential process is taking place as it allows you to quickly get the most recent node in the process. See the <cite>Bartlett1932</cite> demo for an example of it in action.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get vectors in the network.</span>

<span class="sd">    failed = { False, True, &quot;all&quot; }</span>
<span class="sd">    To get the vectors to/from to a specific node, see Node.vectors().</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">failed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid vector failed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">failed</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">failed</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">.</span><span class="n">query</span>\
            <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>\
            <span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">.</span><span class="n">query</span>\
            <span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">network_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">failed</span><span class="o">=</span><span class="n">failed</span><span class="p">)</span>\
            <span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">vectors()</span></code> returns a list of all the Vectors in the Network (filtered by <code class="docutils literal notranslate"><span class="pre">failed</span></code>). Again this function is probably overkill for most experimental needs. If you want to know who a Node is connected to you should use node functions like <code class="docutils literal notranslate"><span class="pre">node.vectors()</span></code> or <code class="docutils literal notranslate"><span class="pre">node.neighbors()</span></code> instead. But, just in case you really want to get a list of all the Vectors in the Network, this function is here for you.</p>
<p>After this we come to a bunch of functions that ask Networks to do things, let’s take a look.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add the node to the network.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</pre></div>
</div>
<p>Above we mentioned that Networks contain a bunch of rules that determine how the Network grows. <code class="docutils literal notranslate"><span class="pre">add_node</span></code> is one of these and it’s pretty much the most important one. Here it just raises an error though, and this is because the base class <code class="docutils literal notranslate"><span class="pre">Network</span></code> has no structure at all and so doesn’t know how to grow. This function will always be overwritten in specific types of Networks with specific behavior and we’ll see some examples of this very shortly.</p>
<p>Note also that the function takes a Node as a parameter. This is the new Node that has been created, and, because Nodes <em>must</em> have a Network the node is actually already in the Network. What’s happening when this function is called is that the Network is being notified that the Node has been added to it and so the Network can take any action that is necessary (e.g. connecting it to other Nodes, sending it Transmissions and so on). Again, we’ll see some examples of this shortly and we’ll also see how this function is called in specific experiments when we come to the <code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Network</span></code> class also has a <code class="docutils literal notranslate"><span class="pre">fail()</span></code> and <code class="docutils literal notranslate"><span class="pre">print_verbose()</span></code> function, but these aren’t particularly interesting, so let’s skip to <code class="docutils literal notranslate"><span class="pre">calculate_full()</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calculate_full</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set whether the network is full.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This function simply tells the Network to update the value in its full column to reflect its current size. It is called automatically by Dallinger when new Nodes are created so you don’t need to worry about it, but it’s important to know that this function exists and when it is called so that you know how Dallinger is keeping track of these things. The goal of this “book” is to pull back the curtain so that you get to see Dallinger’s inner workings, as once you get to that point, you’ll be able to build new experiments with ease.</p>
</div>
<div class="section" id="kinds-of-networks">
<h2>Kinds of Networks<a class="headerlink" href="#kinds-of-networks" title="Permalink to this headline">¶</a></h2>
<p>Just like with Nodes, Dallinger comes pre-packaged with a bunch of common Networks. You can see them in the file <cite>networks.py</cite> which is in the same directory as <cite>models.py</cite> (<cite>Dallinger/dallinger/networks.py</cite>). Open it up now and find the <code class="docutils literal notranslate"><span class="pre">Chain</span></code> network:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Chain</span><span class="p">(</span><span class="n">Network</span><span class="p">):</span>
</pre></div>
</div>
<p>Note that just like the types of Network it contains a <cite>__mapper_args__</cite> value which is used to fill in the <code class="docutils literal notranslate"><span class="pre">type</span></code> column in the database:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;chain&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>After that the only function it overwrites is <code class="docutils literal notranslate"><span class="pre">add_node()</span></code> which, as mentioned above, is called when a Node is added to the Network. So what does it do? Well, given that the Network is called <cite>Chain</cite> you may have already guessed that this growth rule causes the Network to grow into a linear chain of Nodes. Or as the comment in the code puts it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Source -&gt; Node -&gt; Node -&gt; Node -&gt; ...&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>So, how does it do this? Let’s go through the code line by line. First it gets a list of all of the Nodes in the Network, other than the Node that has just been added:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">other_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
</pre></div>
</div>
<p>If this statement looks strange to you, you might want to look up a tutorial on python list comprehension. Also, note that this function is being run by the Network object, so <code class="docutils literal notranslate"><span class="pre">self</span></code> in the code above refers to the Network. After this it makes sure that, if there are already Nodes in the Network, you aren’t trying to add a Source. This is because Sources cannot receive information (see the Nodes chapter) so if you try to add them to the end of a chain, bad things will happen.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Source</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other_nodes</span><span class="p">:</span>
<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
    <span class="s2">&quot;Chain network already has a nodes, &quot;</span>
    <span class="s2">&quot;can&#39;t add a source.&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>After this the magic happens. If there were any other Nodes in the Network (i.e. if <code class="docutils literal notranslate"><span class="pre">other_nodes</span></code> is not an empty list) it finds the youngest of the Nodes (which, by definition will be the current end of the chain) and tells this Node to connect to the new Node that has just arrived.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">other_nodes</span><span class="p">:</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">other_nodes</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;creation_time&#39;</span><span class="p">))</span>
    <span class="n">parent</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">whom</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
<p>This function alone is all you need to grow a chain. It might feel a bit odd defining Network structure by a growth rule and not by a more top-down “blueprint” style approach, so we will take a look at how some other Networks are constructed, so you can become more familiar with this approach. Here’s the <code class="docutils literal notranslate"><span class="pre">add_node()</span></code> function for the <code class="docutils literal notranslate"><span class="pre">FullyConnected</span></code> network for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add a node, connecting it to everyone and back.&quot;&quot;&quot;</span>
    <span class="n">other_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">other_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">Source</span><span class="p">):</span>
            <span class="n">node</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s2">&quot;from&quot;</span><span class="p">,</span> <span class="n">whom</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">whom</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>This function is in some ways quite similar to that for the Chain: it gets a list of all the other nodes. But, rather than then getting the youngest Node, it goes through all Nodes and links them up to the newcomer Node. Note that while the connection is bidirectional for most Nodes, for Sources it is unidirectional because Sources only transmit and can’t be transmitted to.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Star</span></code> network does almost the opposite to the <code class="docutils literal notranslate"><span class="pre">Chain</span></code>. Whenever a new Node is added it finds the <em>oldest</em> node and connects this to the newly added node.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add a node and connect it to the center.&quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">first_node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;creation_time&#39;</span><span class="p">))</span>
        <span class="n">first_node</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">whom</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">DiscreteGenerational</span></code> is the first example of a moderately complicated Network. This is used for multi-generational evolutionary experiments where participants take part in sequential batches. For an example of an experiment using this see the Rogers demo.</p>
<p><code class="docutils literal notranslate"><span class="pre">DiscreteGenerational</span></code> networks have extra parameters that detemine their behavior. These are <code class="docutils literal notranslate"><span class="pre">generations</span></code> (how many generations you want the Network to run for), <code class="docutils literal notranslate"><span class="pre">generation_size</span></code> (the number of Nodes in each generation) and <code class="docutils literal notranslate"><span class="pre">initial_source</span></code> (whether the first generation connects to a source or just starts from nothing. These must be passed as arguments when the Network is created and you can see them being set in the <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> function as properties 1, 2 and 3:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">property1</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">generations</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">property2</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">generation_size</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">property3</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">initial_source</span><span class="p">)</span>
</pre></div>
</div>
<p>They are also made available as a property so you can do things like <code class="docutils literal notranslate"><span class="pre">network.generation_size</span></code> instead of having to remember that generation size is property 2 and accessing it via <code class="docutils literal notranslate"><span class="pre">network.property2</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">add_node()</span></code> function is quite complicated, so let’s break it down. First it needs to work out what generation the current Node is in. It does this by counting all the Nodes in the Network (excluding the initial source, if it exists) and dividing this by the generation_size. It them assigns this number to the Node as its <code class="docutils literal notranslate"><span class="pre">generation</span></code>. So, if you want to use this Network you need to set up your Nodes to have a property called <code class="docutils literal notranslate"><span class="pre">generation</span></code>. None of the Nodes we have seen so far have this, and so we’ll see how it’s done in the demos later.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">Source</span><span class="p">)]</span>
<span class="n">num_agents</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
<span class="n">curr_generation</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">num_agents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generation_size</span><span class="p">))</span>
<span class="n">node</span><span class="o">.</span><span class="n">generation</span> <span class="o">=</span> <span class="n">curr_generation</span>
</pre></div>
</div>
<p>Once the generation is calculated it works out who the new Node needs a connection with. If the generation is 0 (i.e. this Node is in the first generation) it selects the source, but only if <code class="docutils literal notranslate"><span class="pre">initial_source</span></code> was set to true (otherwise it selects no-one). Note that the function tries to accommodate the possibility of there being multiple sources in the Network, and if this is the case it selects the oldest of these sources.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="n">curr_generation</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_source</span><span class="p">:</span>
<span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_oldest_source</span><span class="p">()</span>
</pre></div>
</div>
<p>If you’re not in the first generation though it picks a Node from the previous generation to be your “parent”. Note that it picks a parent on the bais of their “fitness” which is some numeric representation of their success. As such, fitter nodes are more likely to have children - the essence of an evolutionary simulation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">else</span><span class="p">:</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_fit_node_from_generation</span><span class="p">(</span>
        <span class="n">node_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">),</span>
        <span class="n">generation</span><span class="o">=</span><span class="n">curr_generation</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">_select_oldest_source</span></code> and <code class="docutils literal notranslate"><span class="pre">_select_fit_node_from_generation</span></code> functions are just below, though I’ll leave them up to the reader to understand.</p>
<p>Either way, once the parent Node is selected the last thing to do is to connect the parent to the child and ask the parent to transmit to the child. What is transmitted will depend on the experiment, see the Rogers demo for more details of this.</p>
<p>The file <cite>networks.py</cite> contains a bunch of other Networks too, but I’ll leave those up to the reader to figure out how they work. If you’re struggling to see what a Network does grab a pen and paper and manually sketch out what happens as one Node after another gets added.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Dallinger for Programming Novices</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Part 2: Understanding Dallinger:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="the_players.html">Introducing the Players</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_database.html">The Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="node.html">Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="vector.html">Vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="info.html">Infos</a></li>
<li class="toctree-l1"><a class="reference internal" href="transmission.html">Transmissions</a></li>
<li class="toctree-l1"><a class="reference internal" href="transformation.html">Transformations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Networks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-a-network">What is a Network?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-network-table">The Network Table</a></li>
<li class="toctree-l2"><a class="reference internal" href="#network-objects">Network Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kinds-of-networks">Kinds of Networks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="participant.html">Participants</a></li>
<li class="toctree-l1"><a class="reference internal" href="question.html">Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="experiment.html">The Experiment Class</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="transformation.html" title="previous chapter">Transformations</a></li>
      <li>Next: <a href="participant.html" title="next chapter">Participants</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Thomas J. H. Morgan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="_sources/network.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>